<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>Monster Drive Final</title>
    <style> body { margin: 0; overflow: hidden; } </style>
</head>
<body>
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.150.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.150.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';

        let model = null; 
        const keys = {};  

        // 1. シーン設定
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x87CEEB); 
        scene.fog = new THREE.Fog(0x87CEEB, 10, 100); // 霧を少し奥にしました

        // 2. カメラ（初期位置を安全な場所に）
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 5, 10); 

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        // 床とグリッド
        const plane = new THREE.Mesh(new THREE.PlaneGeometry(200, 200), new THREE.MeshStandardMaterial({ color: 0xdddddd }));
        plane.rotation.x = -Math.PI / 2;
        plane.receiveShadow = true;
        scene.add(plane);
        scene.add(new THREE.GridHelper(200, 200));

        const light = new THREE.DirectionalLight(0xffffff, 1.2);
        light.position.set(5, 10, 7);
        light.castShadow = true;
        scene.add(light);
        scene.add(new THREE.AmbientLight(0x606060));

        // 3. モデル読み込み
        const loader = new GLTFLoader();
        // ★ファイル名の確認をお願いします
        loader.load('models/MONSTER_ENERGIE.glb', (gltf) => { 
            model = gltf.scene; 
            scene.add(model);
            
            model.traverse((n) => { if(n.isMesh) n.castShadow = true; });

            // 位置合わせ
            const box = new THREE.Box3().setFromObject(model);
            const size = box.getSize(new THREE.Vector3());
            const center = box.getCenter(new THREE.Vector3());

            model.position.x += (model.position.x - center.x);
            model.position.y += (model.position.y - center.y);
            model.position.z += (model.position.z - center.z);

            const scale = 3 / size.y; 
            model.scale.set(scale, scale, scale);

            // 再計算して着地
            const box2 = new THREE.Box3().setFromObject(model);
            model.position.y -= box2.min.y;

        }, undefined, (error) => {
            console.error(error);
        });

        document.addEventListener('keydown', (e) => keys[e.key] = true);
        document.addEventListener('keyup', (e) => keys[e.key] = false);

        // 4. アニメーション
        function animate() {
            requestAnimationFrame(animate);

            if (model) {
                const moveSpeed = 0.15; 
                const rotateSpeed = 0.05;

                if (keys['a'] || keys['A']) model.rotation.y += rotateSpeed; 
                if (keys['d'] || keys['D']) model.rotation.y -= rotateSpeed; 

                if (keys['w'] || keys['W']) {
                    model.position.x -= Math.sin(model.rotation.y) * moveSpeed;
                    model.position.z -= Math.cos(model.rotation.y) * moveSpeed;
                }
                if (keys['s'] || keys['S']) {
                    model.position.x += Math.sin(model.rotation.y) * moveSpeed;
                    model.position.z += Math.cos(model.rotation.y) * moveSpeed;
                }

                // --- 修正版カメラ追従ロジック ---
                // モデルの「回転」だけを計算に使う（スケールは無視）
                
                // 1. カメラが居てほしい場所（モデルから見て 後ろ8m, 高さ4m）
                const offset = new THREE.Vector3(0, 4, 8); 
                
                // 2. その場所をモデルの向きに合わせて回転させる
                offset.applyQuaternion(model.quaternion);
                
                // 3. モデルの現在位置に足す
                offset.add(model.position);

                // 4. カメラをそこに移動
                camera.position.lerp(offset, 0.1);
                
                // 5. カメラはモデルを見る（少し上を見るように調整）
                camera.lookAt(model.position.x, model.position.y + 2, model.position.z);
            }

            renderer.render(scene, camera);
        }
        animate();
    </script>
</body>
</html>
