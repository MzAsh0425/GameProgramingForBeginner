<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>Physics Fix: Love Inn</title>
    <style> 
        body { margin: 0; overflow: hidden; } 
        #info {
            position: absolute;
            top: 10px; left: 10px;
            color: white; font-family: sans-serif;
            background: rgba(0,0,0,0.5); padding: 10px;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="info">
        <b>【落下対策済みバージョン】</b><br>
        WASD: 移動 / SPACE: ジャンプ<br>
        Rキー: リセット
    </div>

    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.150.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.150.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { Octree } from 'three/addons/math/Octree.js';
        import { OctreeHelper } from 'three/addons/helpers/OctreeHelper.js';
        import { Capsule } from 'three/addons/math/Capsule.js';

        const clock = new THREE.Clock();
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x222222);
        
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.01, 100);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        document.body.appendChild(renderer.domElement);

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 1);
        dirLight.position.set(5, 10, 7);
        dirLight.castShadow = true;
        scene.add(dirLight);

        const spotLight = new THREE.SpotLight(0xffffff, 2);
        spotLight.angle = Math.PI / 4;
        spotLight.penumbra = 0.5;
        spotLight.castShadow = true;
        scene.add(spotLight);

        // --- 物理設定 ---
        const worldOctree = new Octree();
        const startPosition = new THREE.Vector3(0, 5, 0); // スタート地点

        // ★対策1：カプセルを太くする
        // 半径(radius)を 0.05 -> 0.20 (4倍) に変更
        // これで小さな穴やメッシュの隙間に落ちなくなります
        const playerCollider = new Capsule(
            new THREE.Vector3(0, 0.2, 0), 
            new THREE.Vector3(0, 0.4, 0), 
            0.20
        );
        
        const playerVelocity = new THREE.Vector3();
        const playerDirection = new THREE.Vector3();
        let playerOnFloor = false;
        let playerVisual = null;
        const keys = {};

        // --- 読み込み ---
        const loader = new GLTFLoader();

        loader.load('models/labo.glb', (gltf) => {
            const room = gltf.scene;
            scene.add(room);
            room.traverse((child) => {
                if (child.isMesh) {
                    child.castShadow = true;
                    child.receiveShadow = true;
                    if(child.material) child.material.side = THREE.DoubleSide;
                }
            });
            worldOctree.fromGraphNode(room);

            // 緑の線（デバッグ用）はもう邪魔ならコメントアウトしてもOK
            const helper = new OctreeHelper(worldOctree);
            helper.visible = true;
            scene.add(helper);
        }, undefined, (e) => console.error(e));

        loader.load('models/MONSTER_ENERGIE.glb', (gltf) => {
            playerVisual = gltf.scene;
            scene.add(playerVisual);
            
            const box = new THREE.Box3().setFromObject(playerVisual);
            const size = box.getSize(new THREE.Vector3());
            // 見た目は小さいまま（0.15m）
            const scale = 0.15 / size.y; 
            playerVisual.scale.set(scale, scale, scale);
            playerVisual.traverse(n => { if(n.isMesh) n.castShadow = true; });

        }, undefined, (e) => console.error(e));

        document.addEventListener('keydown', (e) => {
            keys[e.key] = true;
            if (e.key === 'r' || e.key === 'R') resetPlayer();
        });
        document.addEventListener('keyup', (e) => keys[e.key] = false);

        function resetPlayer() {
            playerCollider.start.copy(startPosition);
            playerCollider.end.copy(startPosition).add(new THREE.Vector3(0, 0.2, 0)); // 高さ合わせ
            playerVelocity.set(0, 0, 0);
        }

        function updatePlayer(deltaTime) {
            let damping = Math.exp(-4 * deltaTime) - 1;
            
            if (!playerOnFloor) {
                playerVelocity.y -= 30 * deltaTime; 
                damping *= 0.1; 
            }

            playerVelocity.addScaledVector(playerVelocity, damping);
            const deltaPosition = playerVelocity.clone().multiplyScalar(deltaTime);
            playerCollider.translate(deltaPosition);

            playerCollision();

            if (playerCollider.start.y < -25) {
                resetPlayer();
            }
        }

        function playerCollision() {
            // ここで当たり判定を行う回数が増える
            const result = worldOctree.capsuleIntersect(playerCollider);
            playerOnFloor = false;
            if (result) {
                playerOnFloor = result.normal.y > 0;
                if (!playerOnFloor) {
                    playerVelocity.addScaledVector(result.normal, -result.normal.dot(playerVelocity));
                }
                playerCollider.translate(result.normal.multiplyScalar(result.depth));
            }
        }

        function getForwardVector() {
            camera.getWorldDirection(playerDirection);
            playerDirection.y = 0;
            playerDirection.normalize();
            return playerDirection;
        }
        function getSideVector() {
            camera.getWorldDirection(playerDirection);
            playerDirection.y = 0;
            playerDirection.normalize();
            playerDirection.cross(camera.up);
            return playerDirection;
        }

        function controls(deltaTime) {
            const speed = playerOnFloor ? 5 : 2; 
            if (keys['w'] || keys['W']) playerVelocity.add(getForwardVector().multiplyScalar(speed * deltaTime));
            if (keys['s'] || keys['S']) playerVelocity.add(getForwardVector().multiplyScalar(-speed * deltaTime));
            if (keys['a'] || keys['A']) playerVelocity.add(getSideVector().multiplyScalar(-speed * deltaTime));
            if (keys['d'] || keys['D']) playerVelocity.add(getSideVector().multiplyScalar(speed * deltaTime));
            if ((keys[' '] || keys['Space']) && playerOnFloor) playerVelocity.y = 6;

            if (playerVisual) {
                 if (keys['a'] || keys['A']) playerVisual.rotation.y += 0.05;
                 if (keys['d'] || keys['D']) playerVisual.rotation.y -= 0.05;
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            
            // ★対策2：サブステップ処理
            // 1フレームの時間を「5分割」して、5回計算する。
            // これにより、高速で動いても壁をすり抜ける隙を与えない。
            const STEPS_PER_FRAME = 5;
            const deltaTime = Math.min(0.05, clock.getDelta()) / STEPS_PER_FRAME;

            for (let i = 0; i < STEPS_PER_FRAME; i++) {
                controls(deltaTime);
                updatePlayer(deltaTime);
            }

            // 描画（レンダリング）は最後に1回だけ
            if (playerVisual) {
                // 見た目（缶）を当たり判定（カプセル）の位置に合わせる
                playerVisual.position.copy(playerCollider.start);
                // カプセルが太くなったので、見た目の位置調整も少し変更
                playerVisual.position.y -= 0.2; 

                // カメラ追従
                const offset = new THREE.Vector3(0, 0.3, 0.6);
                offset.applyQuaternion(playerVisual.quaternion);
                offset.add(playerVisual.position);
                camera.position.lerp(offset, 0.2);
                
                const lookAtPos = new THREE.Vector3(0, 0, -1); 
                lookAtPos.applyQuaternion(playerVisual.quaternion);
                lookAtPos.add(playerVisual.position);
                camera.lookAt(lookAtPos);
                
                spotLight.position.set(playerVisual.position.x, playerVisual.position.y + 2, playerVisual.position.z);
                spotLight.target = playerVisual;
            }

            renderer.render(scene, camera);
        }
        animate();
    </script>
</body>
</html>
