<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <title>Splatoon: Mouse Aim</title>
    <style> 
        body { margin: 0; overflow: hidden; } 
        #crosshair {
            position: absolute; top: 50%; left: 50%;
            width: 20px; height: 20px;
            border: 2px solid white; border-radius: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            background: rgba(255, 255, 255, 0.2);
        }
        #info {
            position: absolute; top: 10px; left: 10px;
            color: white; font-family: sans-serif;
            background: rgba(0,0,0,0.5); padding: 10px;
            pointer-events: none;
        }
    </style>
</head>
<body>
    <div id="crosshair"></div>
    <div id="info">
        <b>画面をクリックして操作開始</b><br>
        マウス: 視点移動 / クリック: インク発射<br>
        WASD: 移動 / SPACE: ジャンプ / ESC: 中断
    </div>
    
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.150.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.150.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { Octree } from 'three/addons/math/Octree.js';
        import { Capsule } from 'three/addons/math/Capsule.js';
        import { DecalGeometry } from 'three/addons/geometries/DecalGeometry.js';

        // --- マウス操作用の変数 ---
        let isLocked = false; // マウスがロックされているか
        let cameraRotation = { x: 0, y: Math.PI }; // カメラの角度（Yは初期向き）
        const MOUSE_SENSITIVITY = 0.002; // ★ここで回転スピードを微調整できます

        // インク設定
        const decalMaterial = new THREE.MeshPhongMaterial({ 
            specular: 0x444444,
            map: null, 
            transparent: true, 
            depthTest: true,
            depthWrite: false, 
            polygonOffset: true, 
            polygonOffsetFactor: -4, 
            shininess: 30
        });

        const canvas = document.createElement('canvas');
        canvas.width = 128; canvas.height = 128;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle = '#ffffff';
        ctx.beginPath();
        ctx.arc(64, 64, 30, 0, Math.PI*2);
        ctx.fill();
        for(let i=0; i<10; i++){
            const angle = Math.random() * Math.PI * 2;
            const dist = 30 + Math.random() * 20;
            const r = 5 + Math.random() * 10;
            ctx.beginPath();
            ctx.arc(64 + Math.cos(angle)*dist, 64 + Math.sin(angle)*dist, r, 0, Math.PI*2);
            ctx.fill();
        }
        const decalTexture = new THREE.CanvasTexture(canvas);
        decalMaterial.map = decalTexture;

        const clock = new THREE.Clock();
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x222222);
        
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.01, 100);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 1);
        dirLight.position.set(5, 10, 7);
        scene.add(dirLight);

        let roomGroup = null; 
        const decals = [];
        const worldOctree = new Octree();
        const playerCollider = new Capsule(new THREE.Vector3(0, 5, 0), new THREE.Vector3(0, 5.2, 0), 0.2);
        const playerVelocity = new THREE.Vector3();
        const playerDirection = new THREE.Vector3();
        let playerOnFloor = false;
        let playerVisual = null;
        const keys = {};

        const loader = new GLTFLoader();

        loader.load('models/lab.glb', (gltf) => {
            roomGroup = gltf.scene;
            scene.add(roomGroup);
            roomGroup.traverse((child) => {
                if (child.isMesh) {
                    if (!child.geometry.attributes.normal) {
                        child.geometry.computeVertexNormals();
                    }
                }
            });
            worldOctree.fromGraphNode(roomGroup);
        });

        loader.load('models/MONSTER_ENERGIE.glb', (gltf) => {
            playerVisual = gltf.scene;
            scene.add(playerVisual);
            const box = new THREE.Box3().setFromObject(playerVisual);
            const scale = 0.15 / box.getSize(new THREE.Vector3()).y; 
            playerVisual.scale.set(scale, scale, scale);
        });

        // --- ★マウスロック機能 ---
        document.body.addEventListener('click', () => {
            document.body.requestPointerLock();
        });

        document.addEventListener('pointerlockchange', () => {
            isLocked = (document.pointerLockElement === document.body);
        });

        // --- ★マウス移動イベント（視点操作） ---
        document.addEventListener('mousemove', (event) => {
            if (!isLocked) return;

            // 横回転（Y軸）
            cameraRotation.y -= event.movementX * MOUSE_SENSITIVITY;

            // 縦回転（X軸）※制限付き
            cameraRotation.x -= event.movementY * MOUSE_SENSITIVITY;
            // 真上・真下を見すぎて首が折れないように制限 (-90度〜90度)
            cameraRotation.x = Math.max(-Math.PI / 2 + 0.1, Math.min(Math.PI / 2 - 0.1, cameraRotation.x));
        });

        // --- インク発射 ---
        const raycaster = new THREE.Raycaster();
        const mouseHelper = new THREE.Object3D(); 

        document.addEventListener('mousedown', (event) => {
            if (!isLocked || !roomGroup) return; // ロック中のみ発射

            // 画面中央から発射
            raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
            const intersects = raycaster.intersectObject(roomGroup, true);

            if (intersects.length > 0) {
                const hit = intersects[0];
                if(hit.object.isMesh) {
                    shootInk(hit);
                }
            }
        });

        function shootInk(hit) {
            try {
                const position = hit.point;
                const normal = hit.face.normal.clone(); 
                normal.transformDirection(hit.object.matrixWorld);

                mouseHelper.position.copy(position);
                mouseHelper.lookAt(position.clone().add(normal));
                mouseHelper.rotateZ(Math.random() * Math.PI * 2);

                const size = Math.random() * 0.3 + 0.2; 

                const geometry = new DecalGeometry(
                    hit.object, 
                    position, 
                    mouseHelper.rotation, 
                    new THREE.Vector3(size, size, size)
                );

                const material = decalMaterial.clone();
                material.color.setHSL(Math.random(), 1, 0.5);

                const m = new THREE.Mesh(geometry, material);
                scene.add(m);
                decals.push(m);
            } catch (e) {
                console.error(e);
            }
        }

        // --- 移動処理 ---
        document.addEventListener('keydown', (e) => keys[e.key] = true);
        document.addEventListener('keyup', (e) => keys[e.key] = false);

        function resetPlayer() {
            playerCollider.start.set(0, 5, 0);
            playerCollider.end.set(0, 5.2, 0);
            playerVelocity.set(0,0,0);
        }

        function updatePlayer(deltaTime) {
            let damping = Math.exp(-4 * deltaTime) - 1;
            if (!playerOnFloor) { playerVelocity.y -= 30 * deltaTime; damping *= 0.1; }
            playerVelocity.addScaledVector(playerVelocity, damping);
            playerCollider.translate(playerVelocity.clone().multiplyScalar(deltaTime));
            playerCollision();
            if (playerCollider.start.y < -25) resetPlayer();
        }
        function playerCollision() {
            const result = worldOctree.capsuleIntersect(playerCollider);
            playerOnFloor = false;
            if (result) {
                playerOnFloor = result.normal.y > 0;
                if (!playerOnFloor) playerVelocity.addScaledVector(result.normal, -result.normal.dot(playerVelocity));
                playerCollider.translate(result.normal.multiplyScalar(result.depth));
            }
        }

        // ★移動方向の計算をカメラ向きに合わせる
        function getForwardVector() {
            const v = new THREE.Vector3();
            // カメラの向いている水平方向を取得
            v.set(Math.sin(cameraRotation.y), 0, Math.cos(cameraRotation.y));
            return v.normalize().negate(); // 逆になっていたので反転
        }
        function getSideVector() {
            const v = new THREE.Vector3();
            v.set(Math.sin(cameraRotation.y), 0, Math.cos(cameraRotation.y));
            v.cross(THREE.Object3D.DefaultUp); // 右方向
            return v.normalize().negate();
        }

        function controls(deltaTime) {
            const speed = playerOnFloor ? 5 : 2; 
            if (keys['w'] || keys['W']) playerVelocity.add(getForwardVector().multiplyScalar(speed * deltaTime));
            if (keys['s'] || keys['S']) playerVelocity.add(getForwardVector().multiplyScalar(-speed * deltaTime));
            if (keys['a'] || keys['A']) playerVelocity.add(getSideVector().multiplyScalar(-speed * deltaTime));
            if (keys['d'] || keys['D']) playerVelocity.add(getSideVector().multiplyScalar(speed * deltaTime));
            if ((keys[' '] || keys['Space']) && playerOnFloor) playerVelocity.y = 6;
        }

        function animate() {
            requestAnimationFrame(animate);
            const STEPS = 5;
            const dt = Math.min(0.05, clock.getDelta()) / STEPS;
            for(let i=0; i<STEPS; i++){ controls(dt); updatePlayer(dt); }

            if (playerVisual) {
                // 1. プレイヤーの位置更新
                playerVisual.position.copy(playerCollider.start);
                playerVisual.position.y -= 0.2; 
                
                // 2. プレイヤーの向きをカメラの水平回転に合わせる
                // (缶は常に正面＝カメラ方向を向く)
                playerVisual.rotation.y = cameraRotation.y + Math.PI; 

                // 3. カメラ位置の計算 (球座標)
                // プレイヤーを中心にして、回転角度に応じた位置にカメラを置く
                const cameraDist = 0.6; // 距離
                const cameraHeight = 0.3; // 基準の高さ

                // カメラのオフセット計算
                // X軸回転(Pitch)で高さを、Y軸回転(Yaw)で水平位置を決める
                const offsetX = Math.sin(cameraRotation.y) * cameraDist * Math.cos(cameraRotation.x);
                const offsetZ = Math.cos(cameraRotation.y) * cameraDist * Math.cos(cameraRotation.x);
                const offsetY = Math.sin(cameraRotation.x) * cameraDist;

                camera.position.x = playerVisual.position.x - offsetX;
                camera.position.z = playerVisual.position.z - offsetZ;
                camera.position.y = playerVisual.position.y + cameraHeight - offsetY;

                // 4. カメラはプレイヤーの少し先を見る
                // これにより、常にクロスヘアの中心が狙える
                camera.lookAt(
                    playerVisual.position.x + offsetX * 10,
                    playerVisual.position.y + cameraHeight + offsetY * 10,
                    playerVisual.position.z + offsetZ * 10
                );
            }
            renderer.render(scene, camera);
        }
        animate();
    </script>
</body>
</html>
